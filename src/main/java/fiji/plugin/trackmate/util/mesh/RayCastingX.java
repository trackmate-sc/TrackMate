package fiji.plugin.trackmate.util.mesh;

import gnu.trove.list.array.TDoubleArrayList;
import gnu.trove.list.array.TLongArrayList;
import net.imagej.mesh.Mesh;
import net.imagej.mesh.Triangles;

/**
 * Ray casting algorithm.
 * <p>
 * Used to determine whether a point is inside or outside a mesh. This
 * implementation uses rays cast along X only.
 *
 * @author Jean-Yves Tinevez
 *
 */
public class RayCastingX
{

	private static final boolean DEBUG = false;

	/** List of triangle ids intersecting with the current ray. */
	private final TLongArrayList intersectingTriangle = new TLongArrayList();

	/** List of X positions of the triangle intersections with the ray. */
	private final TDoubleArrayList intersectionXs = new TDoubleArrayList();

	/** List of the X component of normal at intersection point. */
	private final TDoubleArrayList intersectionNormals = new TDoubleArrayList();

	private final Mesh mesh;

	private final MollerTrumbore mollerTrumbore;

	public RayCastingX( final Mesh mesh )
	{
		this.mesh = mesh;
		this.mollerTrumbore = new MollerTrumbore( mesh );
	}

	/**
	 * Returns the position of mesh entries and exists along the specified X
	 * ray. The lists returned are pruned for duplicate and non-alternating
	 * entry / exit points are resolved.
	 *
	 * @param y
	 *            the Y position of the X ray to cast.
	 * @param z
	 *            the Z position of the X ray to cast.
	 * @param meshXs
	 *            List of resolved X positions where we enter / exit the mesh,
	 *            along the specified ray. Modified by this call.
	 * @param meshNs
	 *            List of X component of normals at points where we enter / exit
	 *            the mesh. Modified by this call.
	 *
	 */
	public void cast( final double y, final double z, final TDoubleArrayList meshXs, final TDoubleArrayList meshNs )
	{
		meshXs.resetQuick();
		meshNs.resetQuick();

		// Get all the X position where triangles cross the line.
		getXIntersectingCoords( y, z, intersectingTriangle, intersectionXs );

		// No intersection?
		if ( intersectionXs.isEmpty() )
			return;

		if ( DEBUG )
			MeshUtils.exportMeshSubset( intersectingTriangle.toArray(), mesh, "samples/mesh/io/subset.stl" );

		// Collect normals projection on the X line.
		getNormalXProjection( mesh, intersectingTriangle, intersectionNormals );

		// Sort by by X coordinate of intersections.
		final int[] index = SortArrays.quicksort( intersectionXs );

		// Sort normal array with the same order.
		SortArrays.reorder( intersectionNormals, index );

		if ( DEBUG )
		{
			System.out.println();
			System.out.println( "Before removing duplicates:" );
			System.out.println( "XS: " + intersectionXs );
			System.out.println( "NS: " + intersectionNormals );
		}

		// Merge duplicates.
		final int maxIndex = removeDuplicate( intersectionXs, intersectionNormals );

		if ( DEBUG )
		{
			System.out.println( "After removing duplicates:" );
			System.out.println( "XS: " + intersectionXs.subList( 0, maxIndex ) );
			System.out.println( "NS: " + intersectionNormals.subList( 0, maxIndex ) );
		}

		// Check we are alternating entering / leaving.
		checkAlternating( intersectionXs, intersectionNormals, maxIndex, meshXs, meshNs );
	}

	/**
	 * Remove duplicate positions of intersections.
	 * <p>
	 * It is very likely that the ray casting along X intersects with triangle
	 * edges or triangle vertices. This is because in some case the mesh we
	 * iterate through was generated by the marching-cubes algorithm, and the
	 * mesh vertices lie exactly at pixel coordinates.
	 * <p>
	 * Because of this they ray might intersects at one point with several,
	 * possibly many (3-9) triangles. This routine merges consecutive duplicate
	 * X position by retaining one one for a set, and taking the mean normal of
	 * the set.
	 *
	 * @param ts
	 *            the X position of the intersections of the ray with triangles,
	 *            possibly with duplicates. Will be modified by this routine.
	 * @param nxs
	 *            the X component of the normal of the intersected triangles.
	 *            Will be modified by this call.
	 * @return the new arrays length. That is: the actual size of the
	 *         intersection list once it has been pruned of duplicates.
	 */
	private static final int removeDuplicate( final TDoubleArrayList ts, final TDoubleArrayList nxs )
	{
		if ( ts.size() < 2 )
			return ts.size();

		int j = 0;
		double accum = 0.;
		int nAccum = 0;
		for ( int i = 0; i < ts.size() - 1; i++ )
		{
			if ( ts.getQuick( i ) != ts.getQuick( i + 1 ) )
			{
				ts.setQuick( j, ts.getQuick( i ) );
				if ( nAccum == 0 )
				{
					nxs.setQuick( j, nxs.getQuick( i ) );
				}
				else
				{
					// Average.
					nxs.setQuick( j, accum / nAccum );
				}
				accum = 0.;
				nAccum = 0;
				j++;
			}
			else
			{
				final double v = nxs.getQuick( i );
				accum += v;
				nAccum++;
			}
		}

		ts.setQuick( j, ts.getQuick( ts.size() - 1 ) );
		if ( nAccum == 0 )
			nxs.setQuick( j, nxs.getQuick( ts.size() - 1 ) );
		else
			nxs.setQuick( j, accum / nAccum );

		j++;
		return j;
	}

	/**
	 * Processes entries and exists along a ray in the mesh.
	 * <p>
	 * Ideally, following a ray, every time we cross a triangle at an entry, it
	 * should be followed by an exit and vice-versa. When it is not the case, it
	 * means the ray has been following triangles exactly parallels to the X
	 * axis. This routine resolves theses issues by returning new arrays where
	 * non alternating entries and exits have been pruned. It retains the
	 * 'leftmost' entry and the 'rightmost' exit every time several consecutive
	 * entries or exits are encountered.
	 *
	 * @param xs
	 *            the array of X position of intersection points.
	 * @param nxs
	 *            the array of X component of the normals at these intersection
	 *            points.
	 * @param maxIndex
	 *            the size of these arrays (actual arrays might be bigger, but
	 *            they won't be iterated past this size).
	 * @param outXs
	 *            a holder for the resulting pruned X positions of intersection
	 *            points. Reset by this call. Must be empty when called.
	 * @param outNxs
	 *            a holder for the resulting X component of the normals at
	 *            intersection points. Reset by this call. Must be empty when
	 *            called.
	 */
	private static final void checkAlternating(
			final TDoubleArrayList xs, final TDoubleArrayList nxs, final int maxIndex,
			final TDoubleArrayList outXs, final TDoubleArrayList outNxs )
	{
		double prevN = nxs.getQuick( 0 );
		final double prevX = xs.getQuick( 0 );

		outXs.add( prevX );
		outNxs.add( prevN );

		// The first one should be an entry (normal neg).
		assert prevN < 0;
		// The last one should be an exit (normal pos).
		assert nxs.getQuick( maxIndex ) > 0;

		for ( int i = 1; i < maxIndex; i++ )
		{
			final double n = nxs.getQuick( i );
			if ( n * prevN < 0. )
			{
				// Sign did change. All good.
				outXs.add( xs.getQuick( i ) );
				outNxs.add( n );
			}
			else
			{
				// Sign did not change! Merge.
				if ( n < 0. )
				{
					// Two consecutive entries.
					// Remove this one, so that the first valid entry stays.
				}
				else
				{
					// Two consecutive exits.
					// Remove the previous one, so that the last exit is
					// this one.
					outXs.removeAt( outXs.size() - 1 );
					outNxs.removeAt( outNxs.size() - 1 );
					// And add this one.
					outXs.add( xs.getQuick( i ) );
					outNxs.add( n );
				}
			}
			prevN = n;
		}
	}

	/**
	 * Returns the list of X coordinates where the line parallel to the X axis
	 * and passing through (0,y,z) crosses the triangles of the mesh. The list
	 * is unordered and may have duplicates.
	 *
	 * @param y
	 *            the Y coordinate of the line origin.
	 * @param z
	 *            the Z coordinate of the line origin.
	 * @param tl
	 *            a holder for the triangle indices intersecting.
	 * @param ts
	 *            a holder for the resulting intersections X coordinate.
	 */
	private void getXIntersectingCoords( final double y, final double z,
			final TLongArrayList tl, final TDoubleArrayList ts )
	{
		final double[] intersection = new double[ 3 ];
		tl.resetQuick();
		ts.resetQuick();
		// TODO optimize search of triangles with a data structure.
		for ( long id = 0; id < mesh.triangles().size(); id++ )
			if ( mollerTrumbore.rayIntersectsTriangle( id, 0, y, z, 1., 0, 0, intersection ) )
			{
				tl.add( id );
				ts.add( intersection[ 0 ] );
			}
	}

	private static void getNormalXProjection( final Mesh mesh, final TLongArrayList tl, final TDoubleArrayList nxs )
	{
		nxs.resetQuick();
		final Triangles triangles = mesh.triangles();
		for ( int id = 0; id < tl.size(); id++ )
			nxs.add( triangles.nx( tl.getQuick( id ) ) );
	}

}
